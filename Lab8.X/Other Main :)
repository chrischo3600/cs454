/*
 * File:   main.c
 * Author: team-7a
 *
 * Created on April 17, 2024, 3:06 PM
 */

#include <p33Fxxxx.h>
//do not change the order of the following 3 definitions
#define FCY 12800000UL 
#include <stdio.h>
#include <libpic30.h>
#include <uart.h>
#include <xc.h>
#include "types.h"
#include "led.h"
#include "lcd.h"
#include "joystick.h"
#include <stdlib.h>
#define CHAN_X 8
#define CHAN_Y 7
#define SERVOS_LO 900
#define SERVOS_HI 2100
#define SERVOS_MEAN 1500
#define NUM_SAMPLES 5
#define TOUCH_MID_X 1900.0
#define TOUCH_MID_Y 2000.0
#define BUTTER_ORD 3
#define X 0
#define Y 1


#define KPx 0.08
#define KDx 0.001
#define KIx 0.0

#define KPy 0.08
#define KDy 0.001
#define KIy 0.0


// butterworth ord 3
// Wn = (2)/(20/2)  # in hz filter
// fs = 20  # Sample rate in hz
// N = 3
//double b[4] = {2.91464945e-05, 8.74394834e-05, 8.74394834e-05,  2.91464945e-05};
//double a[4] = { 1.,        -2.87435689,  2.7564832, -0.88189313};

// Wn = (5)/(20/2)  # in hz filter
// fs = 20  # Sample rate in hz
// N = 3
double b[4] = {0.00041655, 0.00124964, 0.00124964,  0.00041655};
double a[4] = { 1.,        -2.6861574,  2.41965511, -0.73016535};

// Wn = (20)/(20/2)  # in hz filter
// fs = 20  # Sample rate in hz
// N = 3
//double b[4] = {0.01809893, 0.0542968,  0.0542968, 0.01809893};
//double a[4] = { 1.,         -1.76004188,  1.18289326, -0.27805992};

int val;
int filter; 
double lastErrorX = 0; 
double sumErrorX = 0;

int isX = 1;

double lastErrorY = 0; 
double sumErrorY = 0;


/* Initial configuration by EE */
// Primary (XT, HS, EC) Oscillator with PLL
_FOSCSEL(FNOSC_PRIPLL);

// OSC2 Pin Function: OSC2 is Clock Output - Primary Oscillator Mode: XT Crystal
_FOSC(OSCIOFNC_OFF & POSCMD_XT); 

// Watchdog Timer Enabled/disabled by user software
_FWDT(FWDTEN_OFF);

// Disable Code Protection
_FGS(GCP_OFF);  

void set_motor_angle(uint8_t channel, uint16_t us_value) {
    motor_set_duty(channel, us_value);
}

int compare( const void* a, const void* b)
{
     int int_a = * ( (int*) a );
     int int_b = * ( (int*) b );

     if ( int_a == int_b ) return 0;
     else if ( int_a < int_b ) return -1;
     else return 1;
}




void __attribute__((__interrupt__)) _T3Interrupt(void) {
    TMR3=0;
    if (isX < 5) {
        touch_select_dim(X);
    } else {
        touch_select_dim(Y);
    }
    __delay_ms(10);
    val = touch_read();
    filter = 1;
    CLEARBIT(IFS0bits.T3IF);
}

int online_filter(double sampled_value, int * inputs, int * outputs) {
    double retval;
	int i;

	// Perform sample shift
	for (i = BUTTER_ORD; i > 0; --i) {
		inputs[i] = inputs[i-1];
		outputs[i] = outputs[i-1];
	}
	inputs[0] = sampled_value;

	// Compute filtered value
	retval = 0;
	for (i = 0; i < BUTTER_ORD+1; ++i) {
		retval += inputs[i] * b[i];
		if (i > 0)
			retval -= outputs[i] * a[i];
	}
    
	outputs[0] = retval;
   

	return retval;
    
}

double pid_controller_x(int x, double kp, double kd, double ki) {
    double errorX = x - TOUCH_MID_X;
    sumErrorX += errorX;
    double errChange = errorX - lastErrorX;
    lastErrorX = errorX;
    //lcd_locate(0, 2);
    //lcd_printf_d("error: %f", errorX);
    
    // error
    double P = kp * errorX * SERVOS_HI; 
    //lcd_locate(0, 3);
    //lcd_printf_d("P: %f", P);
    // rate of sampling in seconds
    double dt = 50.0/1000.0;
    
    // derivative of error 
    double D = kd * (errChange/dt) * SERVOS_HI;
    
    // integral of errors
    double I = ki * sumErrorX * SERVOS_HI;
    
    return - P - D - I;
}

double pid_controller_y(int y, double kp, double kd, double ki) {
    double errorY = y - TOUCH_MID_Y;
    sumErrorY += errorY;
    double errChange = errorY - lastErrorY;
    lastErrorY = errorY;
    
    // error
    double P = kp * errorY; 
    // rate of sampling in seconds
    double dt = 50.0/1000.0;
    
    // derivative of error 
    double D = kd * (errChange/dt);
    
    // integral of errors
    double I = ki * sumErrorY;
    
    return - P - D - I;
}




int main(){
    __C30_UART=1;	
	lcd_initialize();
    led_initialize();
	lcd_clear();
    int i;
    motor_init(CHAN_Y);
    set_motor_angle(CHAN_Y, SERVOS_MEAN);
    
    
    __delay_ms(10);
    int inputsX[BUTTER_ORD+1] = {0, 0, 0, 0};
    int outputsX[BUTTER_ORD+1] = {0, 0, 0, 0};
    
    int inputsY[BUTTER_ORD+1] = {0, 0, 0, 0};
    int outputsY[BUTTER_ORD+1] = {0, 0, 0, 0};
    
   
    touch_init();
    

    
    //setup Timer 2
    __builtin_write_OSCCONL(OSCCONL | 2);
    CLEARBIT(T3CONbits.TON); // Disable Timer
    CLEARBIT(T3CONbits.TCS); // Select internal instruction cycle clock
    CLEARBIT(T3CONbits.TGATE); // Disable Gated Timer mode
    TMR3 = 0x00; // Clear timer register
    T3CONbits.TCKPS = 0b11; // Select 1:256 Prescaler
    PR3 = 2500; // 50000/(1000/50 ms)
    IPC2bits.T3IP = 0x01; // Set Timer1 Interrupt Priority Level
    CLEARBIT(IFS0bits.T3IF);
    SETBIT(IEC0bits.T3IE); // Enable Timer1 interrupt
    SETBIT(T3CONbits.TON); // Start Timer
 
    int counter = 0;
    
    lcd_locate(0, 0);
    lcd_printf_d("x:(%.2f,%.2f,%.2f)    ", KPx, KIx, KDx);
    lcd_locate(0, 1);
    lcd_printf_d("y:(%.2f,%.2f,%.2f)    ", KPy, KIy, KDy);
    lcd_locate(0, 2);
    lcd_printf_d("SET:(%.1f, %.1f)    ", TOUCH_MID_X, TOUCH_MID_Y);

    

    while(1) {
        int filtered_valX;
        int filtered_valY;
double pid;

        if (filter) {
            if (isX) {
                motor_init(CHAN_X);
                filtered_valX = online_filter(val, &inputsX, &outputsX);
                //lcd_locate(0, 0);
                //lcd_printf_d("x_val: %d    ", filtered_valX);

                pid = pid_controller_x(filtered_valX, KPx, KDx, KIx);
                lcd_locate(0, 5);
                lcd_printf_d("%.2f    ", pid);
                //pid += SERVOS_MEAN;
                //set_motor_angle(CHAN_X, (int)pid);
                //isX = 0;
            } else {
                motor_init(CHAN_Y);
                filtered_valY = online_filter(val, &inputsY, &outputsY);

                pid = pid_controller_y(filtered_valY, KPy, KDy, KIy);
                //pid += SERVOS_MEAN;
                set_motor_angle(CHAN_Y, (int)pid);
                isX = 1;
            }
            
            filter = 0;
            counter++;
            
        }
        lcd_locate(0,3);
        if (counter == 5) {
            lcd_printf_d("LOC: (%d, %d)    ", filtered_valX, filtered_valY);
            lcd_locate(0,4);
            lcd_printf_d("%.2f    ", pid);
            counter = 0;
        } 
    
    }
    
    
}





lcd_locate(0, 0);
lcd_printf_d("---- Lab 8 ----");





