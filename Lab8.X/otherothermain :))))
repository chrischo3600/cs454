/*
 * File:   main.c
 * Author: team-7a
 *
 * Created on April 17, 2024, 3:06 PM
 */

#include <p33Fxxxx.h>
//do not change the order of the following 3 definitions
#define FCY 12800000UL 
#include <stdio.h>
#include <libpic30.h>
#include <uart.h>
#include <xc.h>
#include "types.h"
#include "led.h"
#include "lcd.h"
#include "joystick.h"
#include <stdlib.h>
#define CHAN_X 8
#define CHAN_Y 7
#define SERVOS_LO 900
#define SERVOS_HI 2100
#define SERVOS_MEAN 1500
#define NUM_SAMPLES 5
#define TOUCH_MID_X 1900.0
#define TOUCH_MID_Y 1850.0
#define BUTTER_ORD 3
#define X 0
#define Y 1
#define KP 0.2
#define KD 0.1
#define KI 0

//#define KP 0.15
//#define KD 0.05
//#define KI 0.001


// butterworth ord 3
// Wn = (5)/(20/2)  # in hz filter
// fs = 20  # Sample rate in hz
// N = 3
//double b[4] = {0.00041655, 0.00124964, 0.00124964,  0.00041655};
//double a[4] = { 1.,        -2.6861574,  2.41965511, -0.73016535};

double b[4] = {0.01809893, 0.0542968,  0.0542968, 0.01809893};
double a[4] = { 1.,         -1.76004188,  1.18289326, -0.27805992};

int val;
int filter; 
double lastErrorX = 0; 
double sumErrorX = 0;

int isX = 1;

double lastErrorY = 0; 
double sumErrorY = 0;


/* Initial configuration by EE */
// Primary (XT, HS, EC) Oscillator with PLL
_FOSCSEL(FNOSC_PRIPLL);

// OSC2 Pin Function: OSC2 is Clock Output - Primary Oscillator Mode: XT Crystal
_FOSC(OSCIOFNC_OFF & POSCMD_XT); 

// Watchdog Timer Enabled/disabled by user software
_FWDT(FWDTEN_OFF);

// Disable Code Protection
_FGS(GCP_OFF);  

void set_motor_angle(uint8_t channel, uint16_t us_value) {
    motor_set_duty(channel, us_value);
}

int compare( const void* a, const void* b)
{
     int int_a = * ( (int*) a );
     int int_b = * ( (int*) b );

     if ( int_a == int_b ) return 0;
     else if ( int_a < int_b ) return -1;
     else return 1;
}




void __attribute__((__interrupt__)) _T3Interrupt(void) {
    TMR3=0;
    if (isX) {
        touch_select_dim(X);
        __delay_ms(10);
    } else {
        touch_select_dim(Y);
        __delay_ms(10);
    }
    val = touch_read();
    filter = 1;
    CLEARBIT(IFS0bits.T3IF);
}

int online_filter(double sampled_value, int * inputs, int * outputs) {
    double retval;
	int i;

	// Perform sample shift
	for (i = BUTTER_ORD; i > 0; --i) {
		inputs[i] = inputs[i-1];
		outputs[i] = outputs[i-1];
	}
	inputs[0] = sampled_value;

	// Compute filtered value
	retval = 0;
	for (i = 0; i < BUTTER_ORD+1; ++i) {
		retval += inputs[i] * b[i];
		if (i > 0)
			retval -= outputs[i] * a[i];
	}
	outputs[0] = retval;
   

	return retval;
    
}

double pid_controller_x(int x, double kp, double kd, double ki) {
    double errorX = x - TOUCH_MID_X;
    sumErrorX += errorX;
    double errChange = errorX - lastErrorX;
    lastErrorX = errorX;
    //lcd_locate(0, 2);
    //lcd_printf_d("error: %f", errorX);
    
    // error
    double P = kp * errorX; 
    //lcd_locate(0, 3);
    //lcd_printf_d("P: %f", P);
    // rate of sampling in seconds
    double dt = 50.0/1000.0;
    
    // derivative of error 
    double D = kd * (errChange/dt);
    
    // integral of errors
    double I = ki * sumErrorX;
    
    return - P - D - I;
}
double pid_controller_y(int y, double kp, double kd, double ki) {
    double errorY = y - TOUCH_MID_Y;
    sumErrorY += errorY;
    double errChange = errorY - lastErrorY;
    lastErrorY = errorY;
    
    // error
    double P = kp * errorY; 
    // rate of sampling in seconds
    double dt = 50.0/1000.0;
    
    // derivative of error 
    double D = kd * (errChange/dt);
    
    // integral of errors
    double I = ki * sumErrorY;
    
    return - P - D - I;
}




int main(){
    __C30_UART=1;	
	lcd_initialize();
    led_initialize();
	lcd_clear();
    int i;
    motor_init(CHAN_Y);
    set_motor_angle(CHAN_Y, SERVOS_LO);
    
    
    __delay_ms(10);
    int inputsX[BUTTER_ORD+1] = {0, 0, 0, 0};
    int outputsX[BUTTER_ORD+1] = {0, 0, 0, 0};
    
    int inputsY[BUTTER_ORD+1] = {0, 0, 0, 0};
    int outputsY[BUTTER_ORD+1] = {0, 0, 0, 0};
    
    
    // select x dimension
    touch_init();
    

    
    //setup Timer 2
    __builtin_write_OSCCONL(OSCCONL | 2);
    CLEARBIT(T3CONbits.TON); // Disable Timer
    CLEARBIT(T3CONbits.TCS); // Select internal instruction cycle clock
    CLEARBIT(T3CONbits.TGATE); // Disable Gated Timer mode
    TMR3 = 0x00; // Clear timer register
    T3CONbits.TCKPS = 0b11; // Select 1:256 Prescaler
    PR3 = 2500; // 50000/(1000/50 ms)
    IPC2bits.T3IP = 0x01; // Set Timer1 Interrupt Priority Level
    CLEARBIT(IFS0bits.T3IF);
    SETBIT(IEC0bits.T3IE); // Enable Timer1 interrupt
    SETBIT(T3CONbits.TON); // Start Timer
    
    

    while(1) {
        if (filter) {
            if (isX) {
                motor_init(CHAN_X);
                val = online_filter(val, &inputsX, &outputsX);
                //lcd_locate(0, 0);
                //lcd_printf_d("x_val: %d    ", x_val);

                double pid = pid_controller_x(val, KP, KD, KI);
                pid += SERVOS_MEAN;

                set_motor_angle(CHAN_X, (int)pid);
                isX = 0;
            } else {
                motor_init(CHAN_Y);
                val = online_filter(val, &inputsY, &outputsY);

                double pid = pid_controller_y(val, KP, KD, KI);
                pid += SERVOS_MEAN;
                set_motor_angle(CHAN_Y, (int)pid);
                isX = 1;
                
            }
            filter = 0;
            
            
        }
    
    }
    
    
}

